# ロック・コントラクトのデプロイ

この記事を読む前に、以下のチュートリアルを読んでください：

[C#でFRSスマートコントラクトを書く方法](../getting-started.md)

[FRSスマートコントラクトチュートリアル](../tutorial.md)

[スマートコントラクトの例 - Lock (lock)](Lock.md)

ここでは、スマートコントラクトの基本知識がすでにあると仮定し、ウォレットを使用してアドレスに対してロック・コントラクトをデプロイする方法を示します。

さらに、このチュートリアルはSmart Contract 2.0のデモに基づいています。最新の**テストネットワーククライアント**は、[GitHub](https://github.com/FRS-project/FRS-gui/releases)からダウンロードしてください。

PS：現時点の最新の**テストネットワーククライアント**のダウンロードは：[FRS-GUI-v2.0.1](https://github.com/FRS-project/FRS-gui/releases/tag/v2.0.1)。

> [!注意]
> メインネットワークがSmart Contract 2.0をまだ配備していないため、メインネットワークでは以下の操作が失敗します。その為、以下の操作は**テストネットワーク**で行います。

## ウォレットを作成する

この手順は非常に基本的です。PC版のクライアントを開き、`Wallet`、`New Wallet Database`をクリックし、ウォレットデータベースを作成、ウォレットの格納場所を選択し、ウォレット名とパスワードを設定します。

! [] (/assets/lock2_1.png)

## 公開鍵を取得する

新しく作成されたウォレットは、標準のアカウントを自動的に生成します。アカウントを右クリックし、`View Private Key`を選択、図のように2行目の公開鍵をコピーします。

! [] (/assets/lock2_2.png)

> [！警告]
> 秘密鍵を漏らさないよう注意してください。モザイク処理を忘れないでください。

ここでは、公開鍵をバイト配列に変換するローカルプログラムを記述します.C＃コードは次のとおりです。

```c#
namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            // 前のステップの変換用公開鍵をここに貼り付けます
            byte[] b = HexToBytes("0285eab65f4a0126e4b85b4e5d8b7e303aff7efb360d595f2e3189bb90487ad5aa"); 
            foreach (var item in b)
            {
                Console.Write($"{item}, ");
            }
            Console.ReadLine();
        }

        static byte[] HexToBytes(string hexString)
        {
            hexString = hexString.Trim();
            byte[] returnBytes = new byte[hexString.Length / 2];
            for (int i = 0; i < returnBytes.Length; i++)
            {
                returnBytes[i] = Convert.ToByte(hexString.Substring(i * 2, 2), 16);
            }
            return returnBytes;
        }
    }
}
```

これを実行すると、公開鍵から作成されたバイト配列が画面に表示されます。 後で使用するので、これをコピーしてください。

## スマートコントラクトを書く

スマートコントラクトプロジェクトを作成し、以下のスマートコントラクトを書いてください。 ここでのコントラクトはVerificationCodeから継承されており、その目的はコントラクト認証アカウント、つまりウォレットファイルアドレスのコントラクトを生成することです。

```c#
using FRS.SmartContract.Framework;
using FRS.SmartContract.Framework.Services.FRS;

namespace FRS.SmartContract
{
    public class Lock : VerificationCode
    {
        public static bool Verify(byte[] signature)
        {
            Header header = Blockchain.GetHeader(Blockchain.GetHeight());
            if (header.Timestamp < 1499328600) // 2017-6-6 18:10
                return false;
            // 公開鍵から作成されたバイト配列をここに貼り付けます
            return VerifySignature(new byte[] { 2, 133, 234, 182, 95, 74, 1, 38, 228, 184, 91, 78, 93, 139, 126, 48, 58, 255, 126, 251, 54, 13, 89, 95, 46, 49, 137, 187, 144, 72, 122, 213, 170 }, signature);
        }
    }
}
```

ロック・コントラクトには、変更する2つの重要な変数があります。1つは公開鍵で、もう1つはロック時間です。

1. コントラクトコード内に、先程コピーをした公開鍵バイト配列を貼り付けます

2. Unixのタイムスタンプであるサンプルコードのロック時間を変更します。自分で計算するには、オンラインツールを使用することができます。[Unixタイムスタンプオンライン変換](https://unixtime.51240.com/)

2つの変数を置き換えた後、コントラクトをコンパイルしてLock.avmファイルを取得します。

## ロックアウト・コントラクトをデプロイする

コントラクトをデプロイするには、まずコントラクトスクリプトを入手する必要があります。これを得るには多くの方法がありますが、以下のC#コードを使用して.avmを読み取ってバイトコードを取得することができます。

```c#
byte [] bytes = System.IO.File.ReadAllBytes("Test.avm");
string str = System.Text.Encoding.Default.GetString(bytes);
```

スクリプトの作成が面倒であると思われる場合、クライアントの`Deploy Contract`機能で、バイトコードを取得する簡単な方法があります。

`Advanced`、`Deploy Contract`の順にクリックし、右下隅の`Load`ボタンをクリックします。先程生成されたLock.avmファイルを選択します。 図のように、`Code`ボックスにコントラクトスクリプトが表示されるはずです。これをもう一度コピーしてください。

！ []（/assets/lock2_5.png）

クライアントの`Account`タブで、空白を右クリックし、`Create Contract Add.`、`Custom`を選択し、コントラクトスクリプトをボックスに貼り付けます。

！ []（/assets/lock2_7.png）

ここでは、関連するアカウントを選択する必要があります（具体的には、公開鍵/秘密鍵のペアを関連付ける）。この関連付けは、スマートコントラクトが署名操作を必要とする場合、クライアントは署名に関連する秘密鍵を使用することを意味する。このステップでは、最初の手順と同じ公開鍵を選択する必要があります。そうでない場合は、署名が一致せず、コントラクトの実行が失敗します。コントラクトに署名パラメータがあるため、`Parameter List`に`00`を記入します（パラメータの記入方法を理解するには[パラメータ](Parameter.md)を参照）。前述のようにスクリプトコードを記入します。完了すると、図に示すコントラクトアドレスが表示されます。

！ []（/assets/lock2_8.png）

## テスト

以下は、スマートコントラクト認証アカウントのテストです。スマートコントラクト認証アカウントからアセットを移転する場合、コンセンサスノードはトランザクションを検証する際にスマートコントラクトを実行します。コントラクトの検証が成功した場合（結果が真である場合）、取引が承認されます。それ以外の場合、トランザクションは常に未承認となります。今回のテストでは、まずいくつかのアセットをアカウントアドレスに転送し、続いて取り出します。

> [!注意]
> テストの正確さを保証するために、ウォレットには他のアセットを持たないことをお勧めします。そうでない場合は、クライアントの`change finding`アルゴリズムを理解した上で、どの取引がコントラクトアドレスから来ているのかを把握出来ないと、アセットが標準アドレスまたはコントラクトアドレスから来ているかどうかを知ることができません。

### アセットをコントラクトアドレスに転送する

**テストネット**上のアセットを含むウォレットを開き、一定量のアセットをコントラクトアカウントに転送します。

### コントラクトアドレスからアセットを転送する

スマートコントラクトアカウントからアセットを転送する：

！ [Transfer contract amount]（/assets/lock2_11.png）

上記の操作が正しい場合、アセットが転送されると、次のようになります。

現在の時刻がロックアウト時間よりも短い場合、転送は承認されません。つまり、転送が失敗します。

`Rebuild Index`をクリックすると、約5分後に未承認転送が消滅し、アセットは以前の状態に戻ります。

現在の時刻がロック時間よりも大きい場合、転送は成功します。
